<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[date_time库]]></title>
      <url>/2020/06/01/boost/date-time/</url>
      <content type="html"><![CDATA[<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul>
<li><strong>date_time</strong>库需要编译才能使用  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b2 –with-date_time toolset&#x3D;msvc link&#x3D;static stage</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li>特殊时间概念（枚举值，位于<strong>boost::date_time</strong>命名空间中）<ul>
<li>pos_infin            <em>表示正无限</em></li>
<li>neg_infin            <em>表示负无限</em></li>
<li>not_a_date_time    <em>无限时间</em></li>
<li>min_date_time        <em>可表示的最小日期或时间</em></li>
<li>max_date_time        <em>可表示的最大日期或时间</em></li>
</ul>
</li>
</ul>
<h2 id="date日期组件"><a href="#date日期组件" class="headerlink" title="date日期组件"></a><strong>date</strong>日期组件</h2><ul>
<li><p>概述<br>  <strong>date</strong>是<strong>date_time</strong>库处理日期的核心类，使用一个32位的整数作为内部存储。</p>
</li>
<li><p>命名空间和头文件</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/gregorian/gregorian.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::gregorian;</span><br></pre></td></tr></table></figure>
<!--more--></li>
<li><p>创建日期对象</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date d1;				<span class="comment">//一个值为not_a_date_time的无效日期</span></span><br><span class="line"><span class="function">date <span class="title">d2</span><span class="params">(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;	<span class="comment">//使用数字构造日期</span></span><br><span class="line"><span class="function">date <span class="title">d3</span><span class="params">(<span class="number">2000</span>, Jan, <span class="number">1</span>)</span></span>;	<span class="comment">//使用英文指定月份</span></span><br><span class="line"><span class="function">date <span class="title">d4</span><span class="params">(d2)</span></span>;			<span class="comment">//拷贝构造</span></span><br></pre></td></tr></table></figure>
<p>  <em>如果在创建超过<strong>1400-01-01</strong>到<strong>9999-12-31</strong>或者不存在<strong>2017-02-29</strong>则<strong>date_time</strong>库会抛出异常，使用<strong>std::exception</strong>捕获，<strong>what()</strong>获得错误信息</em></p>
</li>
<li><p>工厂函数<em>位于命名空间：<strong>boost::gregorian</strong></em></p>
<ul>
<li>from_string()                    <em>使用分割符<strong>“/“</strong>，<strong>“-“</strong>分割（”2020/12/12”或”2020-12-12”）</em></li>
<li>from_undelimited_string()        <em>无分割符（20200101）</em><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date d1 = from_string(<span class="string">"2020/12/12"</span>);</span><br><span class="line"><span class="function">date <span class="title">d2</span><span class="params">(from_string(<span class="string">"2020-12-12"</span>))</span></span>;</span><br><span class="line">date d3 = from_undelimited_string(<span class="string">"20200101"</span>);</span><br></pre></td></tr></table></figure>
<em>类<strong>day_clock</strong>是一个天级别的时钟，它是一个工厂类，调用它的静态成员函数<strong>local_day()</strong>或<strong>universal_day()</strong>会返回一个当天的日期对象，分别为本地日期和<strong>UTC</strong>日期。<strong>day_clock</strong>内部使用了<strong>C</strong>标准函数<strong>localtime()</strong>和<strong>gmtime()</strong>，因此<strong>local_day()</strong>的行为依赖操作系统的时区设置</em></li>
</ul>
</li>
<li><p>访问日期</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">date.year();			<span class="comment">//返回年份</span></span><br><span class="line">date.month();			<span class="comment">//返回月份</span></span><br><span class="line">date.day();				<span class="comment">//返回日期</span></span><br><span class="line">date.year_monty_day();	<span class="comment">//同时返回年、月、日</span></span><br><span class="line">date.day_of_week();		<span class="comment">//返回date的星期数（0表示星期天）</span></span><br><span class="line">date.day_of_year();		<span class="comment">//返回当年的第几天</span></span><br><span class="line">date.end_of_month();	<span class="comment">//返回当月的最后一天</span></span><br><span class="line">date.week_namber();		<span class="comment">//返回date所在当年的第几周</span></span><br><span class="line">date.is_infinity();		<span class="comment">//是否是一个无限日期</span></span><br><span class="line">date.is_neg_infinity();	<span class="comment">//是否是一个负无限日期</span></span><br><span class="line">date.is_pos_infinity(); <span class="comment">//是否是一个正无限日期</span></span><br><span class="line">date.is_not_a_date();	<span class="comment">//是否是一个无效日期</span></span><br><span class="line">date.is_special();		<span class="comment">//是否是任意一个特殊日期</span></span><br></pre></td></tr></table></figure></li>
<li><p>日期的输出<br>  位于<strong>boost::gregorian</strong>作用域下提供了3个自由函数。</p>
<ul>
<li>to_simple_string(date)        <em>转换为<strong>YYYY-mmm-DD</strong>格式的字符串</em></li>
<li>to_iso_string(date)            <em>转换为<strong>YYYYMMDD</strong>格式的数字字符串</em></li>
<li>to_iso_extended_string(date)  <em>转换为<strong>YYY-MM-DD</strong>格式的数字字符串</em></li>
<li>支持输入输出流，默认使用<strong>YYYY-mmm-DD</strong>格式</li>
</ul>
</li>
<li><p>和<strong>C</strong>结构<strong>tm</strong>互相转换规则和函数<em>位于命名空间：<strong>boost::gregorian</strong></em></p>
<ul>
<li>to_tm(date): <strong>date</strong>转换到<strong>tm</strong>，将<strong>tm</strong>的时分秒<strong>tm_hour/tm_min/tm_sec</strong>均置为<strong>0</strong>，将夏令时标志<strong>tm_isdst</strong>置为<strong>-1</strong>（表示未知）</li>
<li>date_from_tm(datetm): <strong>tm</strong>转换到<strong>date</strong>,只使用年月日三个成员<strong>tm_year/tm_mon/tm_mday</strong>，其他成员忽略</li>
</ul>
</li>
</ul>
<h3 id="date-duration日期长度"><a href="#date-duration日期长度" class="headerlink" title="date_duration日期长度"></a><strong>date_duration</strong>日期长度</h3><ul>
<li>日期长度是以天为单位的时长，是度量时间长度的标量。它与日期不同，其值可以使任意整数，可正可负。基本的日期长度类是<strong>date_duration</strong></li>
<li><strong>date_duration</strong>支持全序比较操作（==，!=，&lt;，&lt;=），也支持完全的加减和递增递减，还支持除以一个整数但不支持除以另一个<strong>date_duration</strong>，其他运算不支持</li>
<li><strong>date_time</strong>库为<strong>date_duration</strong>定义了一个常用<strong>typedef:days</strong>这个新名字  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="function">days <span class="title">dd1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">days <span class="title">dd2</span><span class="params">(<span class="number">-100</span>)</span></span>;</span><br><span class="line"><span class="function">days <span class="title">dd3</span><span class="params">(<span class="number">255</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>为了方便计算时长，<strong>date_time</strong>库还提供了<strong>months，years，weeks</strong>三个时长类，分辨表示月，年，星期，含义与<strong>days</strong>类似<ul>
<li>months.number_of_months()    <em>取表示的月数</em></li>
<li>years.number_of_years()    <em>获取表示的年数</em></li>
<li><strong>weeks</strong>除构造函数以7为单位以外，其他行为与<strong>days</strong>相同<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">weeks <span class="title">w</span><span class="params">(<span class="number">3</span>)</span></span>;	 <span class="comment">//3个星期</span></span><br><span class="line"><span class="function">months <span class="title">m</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">//5个月</span></span><br><span class="line"><span class="function">years <span class="title">y</span><span class="params">(<span class="number">2</span>)</span></span>;	 <span class="comment">//2年</span></span><br><span class="line">months m2 = y + m; <span class="comment">//2年零5个月（29个月）</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>日期运算<ul>
<li><strong>date</strong>支持加减运算，但两个<strong>date</strong>对象的加法操作毫无意义（<strong>date_time</strong>库会以编译错误的方式通知我们），<strong>date</strong>主要用来与时长进行运算。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算从2000年1月1日到2017年11月18日的天数</span></span><br><span class="line">date d1(2000, 1, 1), d2(2017, 11, 18);</span><br><span class="line">days ds = d2 - d1;	<span class="comment">//6531天</span></span><br><span class="line"></span><br><span class="line">d1 += days(<span class="number">10</span>);		<span class="comment">//2000-1-11</span></span><br><span class="line"></span><br><span class="line">d1 += months(<span class="number">2</span>);	<span class="comment">//2000-3-11</span></span><br><span class="line"></span><br><span class="line">d1 -= weeks(<span class="number">1</span>);		<span class="comment">//2000-3-04</span></span><br><span class="line"></span><br><span class="line">d2 -=years(<span class="number">10</span>);		<span class="comment">//2007-11-18</span></span><br></pre></td></tr></table></figure></li>
<li>日期与特殊日期长度、特殊日期与日期长度进行运算结构也是特殊日期</li>
<li>在与<strong>months、years</strong>这两个类时长计算时需注意<em>如果日期是月末的最后一天，那么加减月或年得到的同样是月末，但当天是月末的28号后，加减到2月份等到的是总是月末，原来天数信息丢失</em><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">date <span class="title">d</span><span class="params">(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">d -= months(<span class="number">1</span>);		<span class="comment">//2017-2-28	变月末，原来30号的日期丢失</span></span><br><span class="line">d -= months(<span class="number">1</span>);		<span class="comment">//2017-1-31	</span></span><br><span class="line">d += months(<span class="number">2</span>);		<span class="comment">//2017-3-31	与原来日期不相等</span></span><br></pre></td></tr></table></figure></li>
<li>使用<strong>days</strong>则不会出现这样的问题，如果担心<strong>weeks、months、years</strong>这些时长类被无意使用可以<strong>undef</strong>宏<strong>BOOST_DATE_TIME_OPTIONAL_GREGORIAN_TYPE</strong>，这样使得<strong>date_time</strong>库不包含它们的定义头文件<strong>&lt;boost/date_time/gregorian/greg_duration_types.hpp&gt;</strong></li>
</ul>
</li>
</ul>
<h3 id="date-period日期区间"><a href="#date-period日期区间" class="headerlink" title="date_period日期区间"></a><strong>date_period</strong>日期区间</h3><ul>
<li><strong>date_time</strong>库使用<strong>date_period</strong>来表示日期区间的概念，它是时间轴上的一个左闭右开的区间，其端点是两个<strong>date</strong>对象。日期区间的左边界必须小于右边界，否则<strong>date_period</strong>将表示一个无效日期区间</li>
<li><strong>date_period</strong>可以指定区间的两个端点构造区间，也可以指定左端点加上时长构造区间  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">date_period <span class="title">dp1</span><span class="params">(date(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>), days(<span class="number">20</span>))</span></span>;</span><br><span class="line"><span class="function">date_period <span class="title">dp1</span><span class="params">(date(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>), date(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>))</span></span>;	<span class="comment">//无效</span></span><br><span class="line"><span class="function">date_period <span class="title">dp1</span><span class="params">(date(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>), days(<span class="number">-20</span>))</span></span>;	<span class="comment">//无效</span></span><br></pre></td></tr></table></figure></li>
<li>成员函数<ul>
<li>begin();         <em>返回区间左端点</em></li>
<li>last();         <em>返回区间右端点</em></li>
<li>end();         <em>返回区间右端点后面一天</em></li>
<li>length();      <em>返回区间长度（天数）</em></li>
<li>is_before();   <em>日期区间是否在某个日期前</em></li>
<li>is_after();    <em>日期区间是否在某个日期后</em></li>
<li>contains();    <em>日期区间是否包含另一个日期区间或日期</em></li>
<li>intersects();  <em>两个日期区间是否存在交集</em></li>
<li>intersection();<em>返回两个区间的交集，如果没有，返回一个无效区间</em></li>
<li>is_adjacent(); <em>两个日期区间是否相邻</em></li>
<li>merge();       <em>返回两个日期区间的并集，如果日期区间无交集或相邻，则返回无效区间</em></li>
<li>span();        <em>合并两个日期区间及两者间的间隔</em></li>
</ul>
</li>
</ul>
<h3 id="日期迭代器"><a href="#日期迭代器" class="headerlink" title="日期迭代器"></a>日期迭代器</h3><ul>
<li><strong>date_time</strong>为日期处理提供了日期迭代器概念，可以使用递增或递减连续访问日期，这些日期迭代器包括<strong>day_iterator、week_iterator、month_iterator、year_iterator</strong>，它们分别以天、周、月、年为单位</li>
<li>日期迭代器重载了比较操作符，不需要用解引用操作符就可以直接比较</li>
<li><em>如果没有<strong>difference_type、pointer、reference</strong>等内部类型定义，就不能使用<strong>std::advance()_或</strong>operator+=<em>_来前进或后退</em></em></li>
</ul>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul>
<li><strong>boost::gregorian::gregorian_calendar</strong>类提供了一些常用静态函数<ul>
<li>is_leap_year()<em>可以判断年份是否是闰年</em></li>
<li>end_of_month_day() <em>返回该月的最后一天</em></li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="time-duration时间组件"><a href="#time-duration时间组件" class="headerlink" title="time_duration时间组件"></a><strong>time_duration</strong>时间组件</h2><ul>
<li>命名空间和头文件  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/date_time/posix_time/posix_time.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::posix_time;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> boost </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[boost安装、编译和配置（windows）]]></title>
      <url>/2020/06/01/boost/install/</url>
      <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>官网<a href="http://www.boost.ort" target="_blank" rel="noopener">boost</a>下载</li>
<li>下载后的压缩包解压任意目录即可<a id="more"></a></li>
<li>解压后的目录  <figure class="image-box">
                <img src="//whenmy.com/blog_img/boost_img/install_img/s4f9846s8f6s4f56sdf48s6f4.png" alt="" title="" class="">
                <p></p>
            </figure>

</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li><strong>Boost</strong>库大部分不需要编译，直接包含头文件即可</li>
<li>如果使用需要编译的库双击<strong>bootstrap.bat</strong>运行批处理<br>  生成<strong>b2.exe</strong>和<strong>bjam.exe</strong>，<strong>bjam.exe</strong>是早期编译<strong>Boost</strong>库的应用程序，我们使用<strong>b2.exe</strong>来编译</li>
<li>查询<strong>Boost</strong>所有需要编译的库名称  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b2 -show-libraries</span><br></pre></td></tr></table></figure></li>
<li>完全编译<strong>Boost</strong>库  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b2 --toolset&#x3D;msvc stage</span><br></pre></td></tr></table></figure>
  <strong>–toolset</strong>指定编译时用到的编译器，<strong>msvc</strong>是微软的编译器，指定版本如<strong>msvc-9.0</strong></li>
<li>局部编译仅用到的库  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b2 --toolset&#x3D;msvc --with-data_time stage</span><br></pre></td></tr></table></figure>
  通过<strong>–with</strong>指定需要编译的库其中<strong>-data_time</strong>是时间相关的库</li>
<li>静态编译选项<strong>link=static</strong></li>
</ul>
<h2 id="VS中配置Boost库"><a href="#VS中配置Boost库" class="headerlink" title="VS中配置Boost库"></a><strong>VS</strong>中配置<strong>Boost</strong>库</h2><ul>
<li>项目 -&gt; 属性 -&gt; <strong>VC++</strong>目录页 -&gt; 包含目录 -&gt; <strong>boost</strong>根目录<figure class="image-box">
                <img src="//whenmy.com/blog_img/boost_img/install_img/UXEDT6T49QXO00Z1XEK.png" alt="" title="" class="">
                <p></p>
            </figure></li>
<li>项目 -&gt; 属性 -&gt; <strong>VC++</strong>目录页 -&gt; 库目录 -&gt; 加入编译好的<strong>lib</strong>目录<figure class="image-box">
                <img src="//whenmy.com/blog_img/boost_img/install_img/QU5UB0LR92OO5HFGN.png" alt="" title="" class="">
                <p></p>
            </figure>

</li>
</ul>
<h2 id="环境验证"><a href="#环境验证" class="headerlink" title="环境验证"></a>环境验证</h2><ul>
<li>代码  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/version.hpp&gt;	</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/config.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Boost数组形式的版本号（107300）</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; BOOST_VERSION	&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//Boost字符串形式的版本号（"1_73"）		</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; BOOST_LIB_VERSION &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;	</span><br><span class="line">	<span class="comment">//操作系统（Win32）</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; BOOST_PLATFORM &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//编译器（Microsoft Visual C++ version 14.2）		</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; BOOST_COMPILER &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;	</span><br><span class="line">	<span class="comment">//标准库（Dinkumware standard library version 650）		</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; BOOST_STDLIB &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>结果<figure class="image-box">
                <img src="//whenmy.com/blog_img/boost_img/install_img/1LVSL358JPQFASV.png" alt="" title="" class="">
                <p></p>
            </figure>

</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> boost </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[timer库]]></title>
      <url>/2020/05/31/boost/timer/</url>
      <content type="html"><![CDATA[<h2 id="timer组件"><a href="#timer组件" class="headerlink" title="timer组件"></a><strong>timer</strong>组件</h2><ul>
<li>概述<br>  <strong>timer</strong>可以测量时间的流逝，是一个小型的计时器，可提供毫秒级别的计时精度和操作函数，提供程序员手工控制使用，他像个秒表。</li>
<li>命名空间和头文件  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/timer.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li>成员函数<ul>
<li>double elapsed() const; <em>获取已流逝的时间</em></li>
<li>void restart(); <em>重新开始计时</em></li>
<li>double elapsed_min() const;<em>返回timer可测量的最小时间单位</em></li>
<li>double elapsed_max() const; <em>返回timer可测量的最大时间单位</em><br><strong>timer</strong>的计时器使用了标准库头文件<strong>&lt;ctime&gt;</strong>里面的<strong>std::clock()</strong>函数，他返回自进程启动以来的<strong>clock</strong>数，每秒的<strong>clock</strong>由宏<strong>CLOCKS_PER_SEC</strong>定义（值由操作系统决定windows下1000）。</li>
</ul>
</li>
<li>使用建议<br>  <strong>timer</strong>接口简单好用，适用于大部分要求不高的程序计时任务，但是使用<strong>timer</strong>时，必须理解<strong>elapsed_min()</strong>和<strong>elapsed_max()</strong>这两个计时精度的含义，它们表名了<strong>timer</strong>的能力。<br>  <em>精度依赖操作系统或编译器，难以做到跨平台;不适合测量大跨度时间段，如年、月、日。</em></li>
</ul>
<h2 id="progress-timer组件"><a href="#progress-timer组件" class="headerlink" title="progress_timer组件"></a><strong>progress_timer</strong>组件</h2><ul>
<li>概述<br>  <strong>progress_timer</strong>也是一个计时器，他派生自<strong>timer</strong>，会在析构时自动输出时间，省去了手动调用<strong>elapsed()</strong>的工作。</li>
<li>命名空间和头文件  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/progress.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br></pre></td></tr></table></figure></li>
<li>用法<br>  <strong>progress_timer</strong>继承了<strong>timer</strong>的全部功能，可以像<strong>timer</strong>一样使用，其次更简明的用法。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明开始计时，出作用域自动输出测量的时间</span></span><br><span class="line">progress_timer t;</span><br></pre></td></tr></table></figure>
  <strong>progress_timer</strong>与<strong>timer</strong>接口相同，唯一区别构造函数允许将析构时的输出定向到指定输入输出流里，默认是<strong>std::cout</strong>，如有需求，可以定向到其他标准输出流(ofstream、ostringstream)或者用<strong>cout.rdbuf()</strong>定向<strong>cout</strong>的输出。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将progress_timer输出定向到stringstream</span></span><br><span class="line"><span class="built_in">stringstream</span> ss;	<span class="comment">//一个字符串流对象</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">progress_timer <span class="title">t</span><span class="params">(ss)</span></span>; <span class="comment">//要求progress_timer输出到ss中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> boost </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[boost库目录]]></title>
      <url>/2020/05/31/boost-index/</url>
      <content type="html"><![CDATA[<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li><a href="/2020/06/01/boost/install/">boost安装、编译和配置</a>（windows）<a id="more"></a>

</li>
</ul>
<h2 id="时间与日期"><a href="#时间与日期" class="headerlink" title="时间与日期"></a>时间与日期</h2><ul>
<li><a href="/2020/05/31/boost/timer/">timer库</a></li>
</ul>
]]></content>
      
        
    </entry>
    
  
  
</search>
